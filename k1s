#!/usr/bin/env bash
############################
# k8s 工具集
############################
version=2.0.0
############参数###########
# 资源名称
resource=$1

# 参数1,接受应用名称
param01=$2

# 动作类型
action=$3

# 扩展参数
param02=$4

# 扩展参数
param03=$5

# 扩展参数
param04=$6

# 命名空间
nameSpace=${K1S_NS:="default"}

# 存储yaml路径,带 / 结尾
savePath=${K1S_PATH}

###########################
# 错误列表，用于删除
err_list=(
	"UnexpectedAdmissionError"
	"Terminating"
	"OutOfcpu"
)

# action 列表
action_list=(
	"ls"
	"list"
	"desc"
	"describe"
	"y"
	"yml"
	"yaml"
	"wide"
	"w"
	"e"
	"exec"
	"auto"
	"delete"
	"del"
	"log"
	"logs"
	"tail"
	"tailf"
	"since"
	"like"
)

############内置函数#############

# 判断结果状态
alert() {
	local val=$1
	local ret=$?
	if [[ ${ret} -eq 0 ]]; then
		yello "${val} 成功"
	else
		red "${val} 失败"
	fi
}
# 提示
green() {
	local val=$1
	echo -e "\033[32m ${val} \033[0m"
}
# 禁止
red() {
	local val=$1
	echo -e "\033[31m ${val} \033[0m"
}
# 警告
yello() {
	local val=$1
	echo -e "\033[33m ${val} \033[0m"
}

blue() {
	local val=$1
	echo -e "\033[34m ${val} \033[0m"
}
# 青绿色
cyan() {
	local val=$1
	echo -e "\033[36m ${val} \033[0m"
}
# retrun 1 is exist. return 0 no exist.
in_array () {     
	arr=$1; # 数组
	param=$2; # 被判断的对象
	shift
	echo "${arr[@]}"
    for elem in "${arr[@]}";
    do		
        [[ "$param" = "$elem" ]] && return 1;		
    done;
    return 0
}

help() {
	scriptName=$0
	scriptName=$(basename "${scriptName}")
	local tools=(
		"----------------- ↓ ☆ 部署 ↓ ------------------"
		"部署:              ${scriptName} apply {资源名称}"
		"--------------- ↓ ☯ 常用资源  ↓ ----------------"		
		"----------------- ↓ ❤ 帮助 ↓ -------------------"
		"查看帮助：         ${scriptName} help|h"
	)
	local tips=(
		"+++++++++++++++++++++++++++++ 环境变量 ++++++++++++++++++++++++++++"
		"1. 设置YAML路径的环境变量方式：export K1S_NS=/home/test/ (必须/结尾)"
		"2. 设置命名空间的环境变量方式：export K1S_PATH=dev"
	)
	local envs=(
		"1. 当前操作的路径：${savePath}"
		"2. 当前操作的空间名：${nameSpace}"
	)
	cat <<EOF
   ⎈ __    ____ ⎈       
|  | _/_   | ______
|  |/ /|   |/  ___/
|    < |   |\___ \ 
|__|_ \|___/____  >
     \/         \/  by 百里(github.com/yezihack/k1s)
    version: ${version}
EOF
	local i=0
	for name in "${tools[@]}"; do
		((i++)) # 自增
		if [[ ${i} -le 9 ]]; then
			inc="0${i}"
		else
			inc=${i}
		fi
		line_count=$(echo "${name}" | grep -c "↓")
		if [ "${line_count}" -gt 0 ]; then
			i=0
			yello "${name}"
		else
			cyan "${inc}. ${name}"
		fi

	done
	echo "TIP:"
	for name in "${tips[@]}"; do
		green "${name}"
	done
	echo "CURRENT:"
	for name in "${envs[@]}"; do
		yello "${name}"
	done
}

tip() {
	local envs=(
		"1. 当前操作的路径：${savePath}"
		"2. 当前操作的空间名：${nameSpace}"
	)
	for name in "${tips[@]}"; do
		green "${name}"
	done
}
# 不支持提示
nosupport() {
	op=$1
	red "当前资源不支持【${op}】操作"
}
# 是否继续函数
IsContinue() {
	local msg=$1
	while true; do
		read -r -p "${msg}" ok
		case "${ok}" in
		[Yy])
			break
			;;
		[Nn])
			echo "安全退出"
			exit 0
			;;
		esac
	done
}

# 用于YES还是NO，YES返回0，NO返回1
IsYesNo() {
	local msg=$1
	while true; do
		read -r -p "${msg}" ok
		case "${ok}" in
		[Yy])
			return 0
			;;
		[Nn])
			return 1
			;;
		esac
	done
}

# 判断当前 kubectl 是否小于1.18版本。返回 1则大于等于1.18，0则小于1.18
IsGtK8sVersion118() {
	version=$(kubectl version | sed -r "s/.*(v[0-9]+\.[0-9]+\.[0-9]+).*/\1/g" | sed -n '1p')
	versionNumber=$(echo "${version}" | sed -r "s/[v\.]//g")
	if [ "${versionNumber}" -ge 1180 ]; then
		return 1
	fi
	return 0
}

# 判断是否支持 action
check_action() {
	in_action=$1	
	exist=0
	for elem in "${action_list[@]}";do
		[[ ${elem} = "${in_action}" ]] && exist=1
	done
	if [ ${exist} -eq 0 ];then
		red "This【${in_action}】action is not supported"
		# 仅支持以下 action 操作。
		cyan "Support list: ${action_list[*]}"
	fi
}

# 进入容器内部操作
autoExecPod() {
	green "++++++++ 进入 ${param01} pod 容器 ++++++++"
	param01=$1
	# 从名称中自动获取 pod 名称
	podsName=$(kubectl get pods -n "${nameSpace}" | grep "${param01}" | sed -n '1p' | awk '{print $1}')
	if [ -z "${podsName}" ]; then
		red "获取 POD 名称失败，请检查或使用 exec-pod 方式。"
		exit 1
	fi
	green "自动获取第一个POD名称: ${podsName}"
	kubectl exec -it -n "${nameSpace}" "${podsName}" /bin/bash
	# 如果出错的话，尝试另一种方式
	local ret=$?
	if [ ${ret} -ne 0 ]; then
		green "bash 方式失败，正在尝试 sh 方式进入容器："
		kubectl exec -it -n "${nameSpace}" "${podsName}" sh
	fi
}


#########################
check_apply() {
	# 0. 检查
	## 检查设置路径
	if [ -z "${savePath}" ]; then
		red "请设置的YAML路径的环境变量！"
		exit 1
	fi

	## 路径是否有效
	if [ ! -d "${savePath}" ]; then
		red "${savePath} 路径不存在，请检查"
		exit 1
	fi

	green "当前设置的YAML路径: ${savePath}"

	## 检查输入参数
	if [ -z "${param01}" ]; then
		red "请输入您的应用名称！"
		exit 1
	fi

	## 检查应用文件是否存在
	### 判断是否存在后缀，如果存在后缀，就不添加后缀
	gapCount=$(echo "${param01}" | grep -c "\.")
	if [ "${gapCount}" -gt 0 ]; then
		fullFile="${savePath}${param01}"
		param01=$(echo "${param01}" | cut -d . -f1)
	else
		# 默认添加 .yaml 后缀
		fullFile="${savePath}${param01}.yaml"
	fi

	if [ ! -f "${fullFile}" ]; then
		red "${fullFile} 文件不存在，请检查"
		exit 1
	fi
}
# 新部署
apply() {
	tip
	check_apply
	kubectl get -f "${fullFile}" &>/dev/null
	if [ $? -eq 1 ]; then
		green "############ 正在操作新部署 ###############"
		IsContinue "是否准备好新应用部署：${param01}(Y/N):"
	else
		yello "############ 正在操作重新部署 ###############"
		IsContinue "是否准备好重新部署应用：${param01}(Y/N):"
	fi

	# 模拟运行是否可行
	IsGtK8sVersion118
	if [ $? -eq 1 ]; then
		kubectl apply -f "${fullFile}" --dry-run=client
		alert "client 端，模拟运行"
		kubectl apply -f "${fullFile}" --dry-run=server
		alert "server 端，模拟运行"
	else
		kubectl apply -f "${fullFile}" --dry-run
		alert "client 端，模拟运行"
		kubectl apply -f "${fullFile}" --server-dry-run
		alert "server 端，模拟运行"
	fi

	# 真实运行
	IsContinue "您正在准备运行部署应用名为:${param01},是否确认(Y/N):"
	kubectl apply -f "${fullFile}"

	# 5. 观察应用状态
	kubectl get -f "${fullFile}"

	# 6. 查看应用详情
	IsContinue "是否查看应用:${param01} 的部署详情(Y/N):"
	kubectl describe -f "${fullFile}"
}

# 资源操作大集合
k1s_resource_action() {
	# 资源名称
	resouce_name=$1
	# 是否属于某空间下的资源
	is_ns=$2
	# 参数01，即具体名称，如 pod 名称,还兼容 wide
	param_name=$3
	# 动作名称，默认为 list	
	action_name=${4:="list"}
	# 扩展参数
	param05=$5
	# 扩展参数
	param06=$6
	# 扩展参数
	param07=$7
	echo "资源名称:${resouce_name}, is_ns: ${is_ns}, 参数01:${param_name}, 动作名称:${action_name}"
	# 输出基础信息
	yello "######## namespace:${nameSpace} # resouce-name:${resouce_name} # action:${action_name} ########"
	# 检查 Action 是否有效
	check_action "${action_name}"

	# 分支判断
	case "X${action_name}" in
	"Xlist") # 获取资源列表
		if [ -z "${param_name}" ];then
			kubectl -n ${nameSpace} get "${resouce_name}"
		elif [ "${param_name}" = "wide" ]; then 
			kubectl -n ${nameSpace} get "${resouce_name}" -o wide
		else 
			kubectl -n ${nameSpace} get "${resouce_name}" "${param_name}"
		fi
	;;
	"Xlike") # 模糊查找
		kubectl -n ${nameSpace} get "${resouce_name}" |grep -i "${param_name}"
	;;
	"Xdescribe" | "Xdesc") # 查看资源详情
		kubectl -n ${nameSpace} describe "${resouce_name}" "${param_name}"
	;;
	"Xyaml" | "Xyml" | "Xy") # 查看资源YAML
		kubectl -n ${nameSpace} get "${resouce_name}" "${param_name}" -o yaml
	;;
	"Xexec"| "Xe" | "Xauto") # 进入容器，只限 pods
		if [ "${resouce_name}" = "pods" ];then
			autoExecPod "${param_name}"
		else
			nosupport "${action_name}"
			exit 0
		fi
	;;
	"Xdelete" | "Xdel")
		no_support_resource=("nodes" "clean")
		if echo "${no_support_resource[@]}" | grep -qw "${resouce_name}"; then
			nosupport "${action_name}"
			exit 0
		fi
		IsContinue "当前是【delete】请谨慎操作,是否删除资源【${param_name}】(Y/N):"
		kubectl -n ${nameSpace} delete "${resouce_name}" "${param_name}"
		if [ $? -eq 0 ]; then 
			green "资源【${param_name}】 删除成功"
		else 
			red "资源【${param_name}】 删除失败"
		fi
	;;
	"Xlogs"|"Xlog") # 输出全部日志
		# previous
		previous=${param05}		
		containerName=${param06}		
		if [ -n "$(echo "${previous}"| sed -n "/^[0-9]\+$/p")" ];then # 表示数字
			showNumber=${previous}
			kubectl -n ${nameSpace} logs --tail="${showNumber}" "${param_name}"
			[[ $? -ne 0 ]] && exit 0
			cyan "++++++++++++++++++++++++++ 显示最近 ${showNumber} 条数据 ++++++++++++++++++++++++++ "
		elif [ "${previous}" = "p" ];then
			# 如果 param06 是数字则将 containerName 设置为空
			if [ -n "$(echo "${param06}"| sed -n "/^[0-9]\+$/p")" ];then # 表示数字
				containerName=""
			fi
			# 如果没有 container 则 param06 判断是否数字
			if [ -z "${containerName}" ];then 
				showNumber=${param06}
				if [ -n "$(echo "${showNumber}"| sed -n "/^[0-9]\+$/p")" ];then # 表示数字
					kubectl -n ${nameSpace} logs -p --tail="${showNumber}" "${param_name}"
					[[ $? -ne 0 ]] && exit 0
					cyan "++++++++++++++++++++++++++ 显示最近 ${showNumber} 条数据 ++++++++++++++++++++++++++ "
				else
					kubectl -n ${nameSpace} logs -p "${param_name}"
					[[ $? -ne 0 ]] && exit 0
				fi
			else 
				showNumber=${param07}
				if [ -n "$(echo "${showNumber}"| sed -n "/^[0-9]\+$/p")" ];then # 表示数字
					kubectl -n ${nameSpace} logs -p -c "${containerName}" --tail="${showNumber}" "${param_name}"
					[[ $? -ne 0 ]] && exit 0
					cyan "++++++++++++++++++++++++++ 显示最近 ${showNumber} 条数据 ++++++++++++++++++++++++++ "
				else
					kubectl -n ${nameSpace} logs -p -c "${containerName}" "${param_name}"
					[[ $? -ne 0 ]] && exit 0
				fi
			fi
			cyan "+++++++++++++++++++ 正在查看容器先前(previous)的日志 +++++++++++++++++++"
		else
			showNumber=${param06}
			containerName=${param05}
			if [ -z "${containerName}" ];then 
				if [ -n "$(echo "${showNumber}"| sed -n "/^[0-9]\+$/p")" ];then # 表示数字
					kubectl -n ${nameSpace} logs --tail="${showNumber}" "${param_name}"
					cyan "++++++++++++++++++++++++++ 显示最近 ${showNumber} 条数据 ++++++++++++++++++++++++++ "
				else
					kubectl -n ${nameSpace} logs "${param_name}"
				fi				
			else 
				if [ -n "$(echo "${showNumber}"| sed -n "/^[0-9]\+$/p")" ];then # 表示数字
					kubectl -n ${nameSpace} logs -c "${containerName}" --tail="${showNumber}" "${param_name}"
					cyan "++++++++++++++++++++++++++ 显示最近 ${showNumber} 条数据 ++++++++++++++++++++++++++ "
				else
					kubectl -n ${nameSpace} logs -c "${containerName}" "${param_name}"
				fi			
			fi
		fi
	;;
	"Xtail") # 输出最近的日志				
		showNumber=${param05:=50}
		containerName=${param06}
		# 当 param05 传过来的不是纯数字则表示是 container，需要处理一下
		if [ -z "$(echo ${showNumber}| sed -n "/^[0-9]\+$/p")" ];then # 表示非数字
			containerName="${param05}"
			showNumber=50
		fi
		if [ -z "${containerName}" ];then
			kubectl -n ${nameSpace} logs --tail=${showNumber} "${param_name}"
			[[ $? -ne 0 ]] && exit 0
		else
			green "正在查看:【${containerName}】Container Name 日志"
			kubectl -n ${nameSpace} logs --tail=${showNumber} -c "${containerName}" "${param_name}"
			[[ $? -ne 0 ]] && exit 0
		fi		
		cyan "++++++++++++++++++++++++++ 显示最近 ${showNumber} 条数据 ++++++++++++++++++++++++++ "
	;;
	"Xtailf") # 动态监听日志	
		# -c container
		containerName=${param05}
		cyan "+++++++++++++++++ 动态监听日志 +++++++++++++++++"
		if [ -n "${containerName}" ];then 
			green "正在查看:【${containerName}】Container Name 日志"
			kubectl -n ${nameSpace} logs -f --tail=15 -c ${containerName} "${param_name}"
			[[ $? -ne 0 ]] && exit 0
		else
			kubectl -n ${nameSpace} logs -f --tail=15 "${param_name}"
			[[ $? -ne 0 ]] && exit 0
		fi
	;;	
	esac
}


# 清理垃圾
clean() {
	if [ -n "${param01}" ]; then
		# local errMsg="UnexpectedAdmissionError"
		for errMsg in "${err_list[@]}"; do
			IsYesNo "是否查找 ${errMsg} 错误的POD，确认(Y/N):"
			local result=$?
			if [ ${result} -eq 0 ]; then
				count=$(kubectl get pods -n "${param01}" | grep -c "${errMsg}")
				if [ "${count}" -gt 0 ]; then
					IsYesNo "空间：${param01}，错误：${errMsg}，共: ${count} 条数，是否需要清理(Y/N):"
					result=$?
					if [ ${result} -eq 0 ]; then
						green "开始清理..."
						local i=0
						for errPodsName in $(kubectl get pods -n "${param01}" | grep "${errMsg}" | awk '{print $1}'); do
							((i++))
							red "正在处理: ${i}/${count} ${errPodsName}"
							kubectl delete pods -n "${param01}" "${errPodsName}" --grace-period=0 --force
						done
					fi
				else
					green "空间：${param01}，错误：${errMsg}，共: 0 条数"
				fi
			fi
		done
	else
		# local errMsg="UnexpectedAdmissionError"
		for errMsg in "${err_list[@]}"; do
			IsYesNo "查找所有空间下的 ${errMsg} 错误的 POD,确认(Y/N):"
			local result=$?
			if [ ${result} -eq 0 ]; then
				green "正在统计不同空间下的 ${errMsg} 数据："
				kubectl get pods -A | grep "${errMsg}" | awk '{print $1}' | uniq -c

			fi
		done
		yello "若想删除以上统计的错误,则使用 k1s clean <空间名称>"
	fi
}

main() {	
	## 资源名称
	in_resource=""
	# 是否属于某空间下的资源
	in_ns=0
	case "X${resource}" in
	"Xapply")
		apply
		;;
	"Xcs" | "Xcomponentstatuses")
		in_resource="componentstatuses"
		;;
	"Xconfigmaps" | "Xcm")
		in_resource="configmaps"
		in_ns=1
		;;
	"Xendpoints" | "Xep")
		in_resource="endpoints"
		in_ns=1
		;;
	"Xevents" | "Xev")
		in_resource="events"
		in_ns=1
		;;
	"Xlimitranges" | "Xlimits" | "Xlimit")
		in_resource="limitranges"
		in_ns=1
		;;
	"Xnamespaces" | "Xns")
		in_resource="namespaces"
		;;	
	"Xnodes" | "Xno")
		in_resource="nodes"
		;;
	"Xpersistentvolumeclaims" | "Xpvc")
		in_resource="persistentvolumeclaims"
		in_ns=1
		;;
	"Xpersistentvolumes" | "Xpv")
		in_resource="persistentvolumes"
		;;
	"Xpods" | "Xpo" | "Xps")
		in_resource="pods"
		in_ns=1
		;;
	"Xreplicationcontrollers" | "Xrc")
		in_resource="replicationcontrollers"
		in_ns=1
		;;
	"Xsecrets" | "Xsecret" | "Xsec")
		in_resource="secrets"
		in_ns=1
		;;
	"Xservices" | "Xsvc")
		in_resource="services"
		in_ns=1
		;;
	"Xdaemonsets" | "Xds")
		in_resource="daemonsets"
		in_ns=1
		;;
	"Xdeployments" | "Xdeploy" | "Xd")
		in_resource="deployments"
		in_ns=1
		;;
	"Xreplicasets" | "Xrs")
		in_resource="replicasets"
		in_ns=1
		;;
	"Xstatefulsets" | "Xsts")
		in_resource="statefulsets"
		in_ns=1
		;;
	"Xhorizontalpodautoscalers" | "Xhpa")
		in_resource="horizontalpodautoscalers"
		in_ns=1
		;;
	"Xcronjobs" | "Xcj")
		in_resource="cronjobs"
		in_ns=1
		;;
	"Xjobs" | "Xjob")
		in_resource="jobs"
		in_ns=1
		;;
	"Xingresses" | "Xing")
		in_resource="ingresses"
		in_ns=1
		;;
	"Xingressclasses" | "Xingc")
		in_resource="ingressclasses"
		;;
	"Xclusterrolebindings" | "Xcrb")
		in_resource="clusterrolebindings"
		;;
	"Xserviceaccounts" | "Xsa")
		in_resource="serviceaccounts"
		in_ns=1
		;;
	"Xclusterroles" | "Xcr")
		in_resource="clusterroles"
		;;
	"Xrolebindings" | "Xrb")
		in_resource="rolebindings"
		;;
	"Xroles" | "Xro")
		in_resource="roles"
		in_ns=1
		;;
	"Xclean" | "Xc")
		clean
		;;
	*)
		help
		;;
	esac
	# 拼接成完整的命令
	if [ "${in_resource}" != "" ]; then 
		# 资源名称 是否是某空间下的资源 参数01 动作名称 		
		k1s_resource_action "${in_resource}" ${in_ns} ${param01} ${action} ${param02} ${param03} ${param04}
	fi	
}

main "$@"
