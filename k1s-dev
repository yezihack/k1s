#!/usr/bin/env bash
############################
# k8s 工具集
############################
version=0.2.0
############参数###########
# 资源名称
resource=$1

# 参数1,接受应用名称
param01=$2

# 动作类型
action=$3

# 命名空间
nameSpace=${K1S_NS}

# 存储yaml路径,带 / 结尾
savePath=${K1S_PATH}

###########################
# 错误列表，用于删除
err_list=(
	"UnexpectedAdmissionError"
	"Terminating"
	"OutOfcpu"
)

# action 列表
action_list=(
	"ls"
	"list"
	"desc"
	"describe"
	"y"
	"yaml"
	"wide"
	"w"
	"e"
	"exec"
	"delete"
	"del"
	"log"
	"logs"
	"tail"
	"tailf"
	"since"
)

############内置函数#############

# 判断结果状态
alert() {
	local val=$1
	local ret=$?
	if [[ ${ret} -eq 0 ]]; then
		yello "${val} 成功"
	else
		red "${val} 失败"
	fi
}
# 提示
green() {
	local val=$1
	echo -e "\033[32m ${val} \033[0m"
}
# 禁止
red() {
	local val=$1
	echo -e "\033[31m ${val} \033[0m"
}
# 警告
yello() {
	local val=$1
	echo -e "\033[33m ${val} \033[0m"
}

blue() {
	local val=$1
	echo -e "\033[34m ${val} \033[0m"
}
# 青绿色
cyan() {
	local val=$1
	echo -e "\033[36m ${val} \033[0m"
}
help() {
	scriptName=$0
	scriptName=$(basename "${scriptName}")
	local tools=(
		"----------------- ↓ ☆ 部署 ↓ ------------------"
		"部署:              ${scriptName} apply {资源名称}"		
		"----------------- ↓ ❤ 帮助 ↓ -------------------"
		"查看帮助：             ${scriptName} help|h"
	)
	local tips=(
		"1. 设置YAML路径的环境变量方式：export K1S_NS=/home/test/ (必须/结尾)"
		"2. 设置命名空间的环境变量方式：export K1S_PATH=dev"
	)
	local envs=(
		"1. 当前操作的路径：${savePath}"
		"2. 当前操作的空间名：${nameSpace}"
	)
	cat <<EOF
   ⎈ __    ____ ⎈       
|  | _/_   | ______
|  |/ /|   |/  ___/
|    < |   |\___ \ 
|__|_ \|___/____  >
     \/         \/  by 百里(github.com/yezihack/k1s)
    version: ${version}
EOF
	local i=0
	for name in "${tools[@]}"; do
		((i++)) # 自增
		if [[ ${i} -le 9 ]]; then
			inc="0${i}"
		else
			inc=${i}
		fi
		line_count=$(echo "${name}" | grep -c "↓")
		if [ "${line_count}" -gt 0 ]; then
			i=0
			yello "${name}"
		else
			cyan "${inc}. ${name}"
		fi

	done
	echo "TIP:"
	for name in "${tips[@]}"; do
		green "${name}"
	done
	echo "CURRENT:"
	for name in "${envs[@]}"; do
		yello "${name}"
	done
}

tip() {
	local envs=(
		"1. 当前操作的路径：${savePath}"
		"2. 当前操作的空间名：${nameSpace}"
	)
	for name in "${tips[@]}"; do
		green "${name}"
	done
}

# 是否继续函数
IsContinue() {
	local msg=$1
	while true; do
		read -r -p "${msg}" ok
		case "${ok}" in
		[Yy])
			break
			;;
		[Nn])
			echo "安全退出"
			exit 0
			;;
		esac
	done
}

# 用于YES还是NO，YES返回0，NO返回1
IsYesNo() {
	local msg=$1
	while true; do
		read -r -p "${msg}" ok
		case "${ok}" in
		[Yy])
			return 0
			;;
		[Nn])
			return 1
			;;
		esac
	done
}

# 判断当前 kubectl 是否小于1.18版本。返回 1则大于等于1.18，0则小于1.18
IsGtK8sVersion118() {
	version=$(kubectl version | sed -r "s/.*(v[0-9]+\.[0-9]+\.[0-9]+).*/\1/g" | sed -n '1p')
	versionNumber=$(echo "${version}" | sed -r "s/[v\.]//g")
	if [ "${versionNumber}" -ge 1180 ]; then
		return 1
	fi
	return 0
}

# 判断是否支持 action
check_action() {
	in_action=$1
	for name in "${action_list[@]}"; do
		if [ "${name}" != "${in_action}" ]; then
			red "This ${in_action} is not supported"
			exit 0
		fi
	done
}

#########################
check_apply() {
	# 0. 检查
	## 检查设置路径
	if [ -z "${savePath}" ]; then
		red "请设置的YAML路径的环境变量！"
		exit 1
	fi

	## 路径是否有效
	if [ ! -d "${savePath}" ]; then
		red "${savePath} 路径不存在，请检查"
		exit 1
	fi

	green "当前设置的YAML路径: ${savePath}"

	## 检查输入参数
	if [ -z "${param01}" ]; then
		red "请输入您的应用名称！"
		exit 1
	fi

	## 检查应用文件是否存在
	### 判断是否存在后缀，如果存在后缀，就不添加后缀
	gapCount=$(echo "${param01}" | grep -c "\.")
	if [ "${gapCount}" -gt 0 ]; then
		fullFile="${savePath}${param01}"
		param01=$(echo "${param01}" | cut -d . -f1)
	else
		# 默认添加 .yaml 后缀
		fullFile="${savePath}${param01}.yaml"
	fi

	if [ ! -f "${fullFile}" ]; then
		red "${fullFile} 文件不存在，请检查"
		exit 1
	fi
}
# 新部署
apply() {
	tip
	check_apply
	kubectl get -f "${fullFile}" &>/dev/null
	if [ $? -eq 1 ]; then
		green "############ 正在操作新部署 ###############"
		IsContinue "是否准备好新应用部署：${param01}(Y/N):"
	else
		yello "############ 正在操作重新部署 ###############"
		IsContinue "是否准备好重新部署应用：${param01}(Y/N):"
	fi

	# 模拟运行是否可行
	IsGtK8sVersion118
	if [ $? -eq 1 ]; then
		kubectl apply -f "${fullFile}" --dry-run=client
		alert "client 端，模拟运行"
		kubectl apply -f "${fullFile}" --dry-run=server
		alert "server 端，模拟运行"
	else
		kubectl apply -f "${fullFile}" --dry-run
		alert "client 端，模拟运行"
		kubectl apply -f "${fullFile}" --server-dry-run
		alert "server 端，模拟运行"
	fi

	# 真实运行
	IsContinue "您正在准备运行部署应用名为:${param01},是否确认(Y/N):"
	kubectl apply -f "${fullFile}"

	# 5. 观察应用状态
	kubectl get -f "${fullFile}"

	# 6. 查看应用详情
	IsContinue "是否查看应用:${param01} 的部署详情(Y/N):"
	kubectl describe -f "${fullFile}"
}

# 检查命名空间
checkns() {
	# 检查命名空间
	if [ -z "${nameSpace}" ]; then
		red "请设置命名空间环境变量, 查看帮助:help"
	fi
}
# 检查输入参数
checkParam01() {
	## 检查输入参数
	if [ -z "${param01}" ]; then
		red "请输入您的名称参数！"
		exit 1
	fi
}

# 资源操作大集合
k1s_resource_action() {
	# 资源名称
	resouce_name=$1
	# 是否属于某空间下的资源
	is_ns=$2
	# 参数01
	param_name=$3
	# 动作名称
	action_name=$4
	action_name=${action_name:="list"}

	# 检查 namespace
	if [ "${is_ns}" -eq 1 ];then 
		checkns
	fi

	case "X${action}" in
	"Xlist")
		kubectl get ${resouce_name}
	;;
	"Xdescribe" | "Xdesc")

	;;
	"Xyaml" | "Xy")

	;;
	"Xexec"| "Xe" | "Xauto")

	;;
	"Xdelete" | "Xdel")

	;;
	"Xlogs"|"Xlog")

	;;
	*)

	;;	
	esac
}


# 清理垃圾
clean() {
	if [ -n "${param01}" ]; then
		# local errMsg="UnexpectedAdmissionError"
		for errMsg in "${err_list[@]}"; do
			IsYesNo "是否查找 ${errMsg} 错误的POD，确认(Y/N):"
			local result=$?
			if [ ${result} -eq 0 ]; then
				count=$(kubectl get pods -n "${param01}" | grep -c "${errMsg}")
				if [ "${count}" -gt 0 ]; then
					IsYesNo "空间：${param01}，错误：${errMsg}，共: ${count} 条数，是否需要清理(Y/N):"
					result=$?
					if [ ${result} -eq 0 ]; then
						green "开始清理..."
						local i=0
						for errPodsName in $(kubectl get pods -n "${param01}" | grep "${errMsg}" | awk '{print $1}'); do
							((i++))
							red "正在处理: ${i}/${count} ${errPodsName}"
							kubectl delete pods -n "${param01}" "${errPodsName}" --grace-period=0 --force
						done
					fi
				else
					green "空间：${param01}，错误：${errMsg}，共: 0 条数"
				fi
			fi
		done
	else
		# local errMsg="UnexpectedAdmissionError"
		for errMsg in "${err_list[@]}"; do
			IsYesNo "查找所有空间下的 ${errMsg} 错误的 POD,确认(Y/N):"
			local result=$?
			if [ ${result} -eq 0 ]; then
				green "正在统计不同空间下的 ${errMsg} 数据："
				kubectl get pods -A | grep "${errMsg}" | awk '{print $1}' | uniq -c

			fi
		done
		yello "若想删除以上统计的错误,则使用 k1s clean <空间名称>"
	fi
}

main() {	
	## 资源转换器
	in_resource=""
	in_ns=0
	case "X${resource}" in
	"Xapply")
		apply
		;;
	"Xcs" | "Xcomponentstatuses")
		in_resource="componentstatuses"
		;;
	"Xconfigmaps" | "Xcm")
		in_resource="configmaps"
		in_ns=1
		;;
	"Xendpoints" | "Xep")
		in_resource="endpoints"
		in_ns=1
		;;
	"Xevents" | "Xev")
		in_resource="events"
		in_ns=1
		;;
	"Xlimitranges" | "Xlimits")
		in_resource="limitranges"
		in_ns=1
		;;
	"Xnamespaces" | "Xns")
		in_resource="namespaces"
		;;	
	"Xnodes" | "Xno")
		in_resource="nodes"
		;;
	"Xpersistentvolumeclaims" | "Xpvc")
		in_resource="persistentvolumeclaims"
		in_ns=1
		;;
	"Xpersistentvolumes" | "Xpv")
		in_resource="persistentvolumes"
		;;
	"Xpods" | "Xpo")
		in_resource="pods"
		in_ns=1
		;;
	"Xreplicationcontrollers" | "Xrc")
		in_resource="replicationcontrollers"
		in_ns=1
		;;
	"Xsecrets" | "Xsec")
		in_resource="secrets"
		in_ns=1
		;;
	"Xservices" | "Xsvc")
		in_resource="services"
		in_ns=1
		;;
	"Xdaemonsets" | "Xds")
		in_resource="daemonsets"
		in_ns=1
		;;
	"Xdeployments" | "Xdeploy" | "Xd")
		in_resource="deployments"
		in_ns=1
		;;
	"Xreplicasets" | "Xrs")
		in_resource="replicasets"
		in_ns=1
		;;
	"Xstatefulsets" | "Xsts")
		in_resource="statefulsets"
		in_ns=1
		;;
	"Xhorizontalpodautoscalers" | "Xhpa")
		in_resource="horizontalpodautoscalers"
		in_ns=1
		;;
	"Xcronjobs" | "Xbj")
		in_resource="cronjobs"
		in_ns=1
		;;
	"Xjobs" | "Xjob")
		in_resource="jobs"
		in_ns=1
		;;
	"Xingresses" | "Xing")
		in_resource="ingresses"
		in_ns=1
		;;
	"Xingressclasses" | "Xingc")
		in_resource="ingressclasses"
		;;
	"Xclusterrolebindings" | "Xcrb")
		in_resource="clusterrolebindings"
		;;
	"Xserviceaccounts" | "Xsa")
		in_resource="serviceaccounts"
		in_ns=1
		;;
	"Xclusterroles" | "Xcr")
		in_resource="clusterroles"
		;;
	"Xrolebindings" | "Xrb")
		in_resource="rolebindings"
		;;
	"Xroles" | "Xro")
		in_resource="roles"
		in_ns=1
		;;
	"Xclean" | "Xc")
		clean
		;;
	*)
		help
		;;
	esac
	# 拼接成完整的命令
	if [ "${in_resource}" != "" ]; then 
		k1s_resource_action "${in_resource}" ${in_ns} $param01 $action
	fi	
}

main "$@"
